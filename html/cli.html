<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CLI Files</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="cli">CLI Files </a></h1><h2><a class="anchor" name="cli_intro">
1. INTRODUCTION</a></h2>
CLI files have suffix of .cli. Each CLI contains four types lines:<ul>
<li>Empty line</li><li>Comment - Any line preceeded by '//' is a line of comment. '//' must be 1st character of the line.</li><li>Directive - C style #ifdef, #ifndef, #include, #submode, #endsubmode and #end are available. The label is defined via command-line arguments to <a class="el" href="mk__parser_8py-source.html">mk_parser.py</a>.</li><li>Command definition - A command definition contains a sequence of tokens separated by spaces.</li></ul>
<h2><a class="anchor" name="cli_empty">
2. Empty Lines</a></h2>
Empty lines can be inserted anywhere to make CLI files more readable. However, it does have an implication on generating help displays. See next section for details.<h2><a class="anchor" name="cli_comment">
3. Comments</a></h2>
Each line of comment must begin with '//'. One cannot append comments to a line of command or directive. A line of comment immediately preceeding a line of command definition is automatically included in the help display (generated by calling <a class="el" href="cparser_8h.html#6c5aeb783eadee922456e5675f9c8c22" title="Walk the parser tree and generate a list of all available commands.">cparser_help_cmd()</a>.) <a class="el" href="cparser_8h.html#6c5aeb783eadee922456e5675f9c8c22" title="Walk the parser tree and generate a list of all available commands.">cparser_help_cmd()</a> walks the parse tree and generating a summary of all available commands. The comment immediately preceeding the command is saved as the description string of that command.<p>
For example, suppose we have the following command.<p>
<pre>
 // Clear all interface counters
 clear interface stats
 </pre><p>
<a class="el" href="cparser_8c.html#ee61c8490212030ff495667278363e17" title="Generate context-sensitive help.">cparser_help()</a> will generate the following:<p>
<pre>
 Clear all interface counters
   clear interface stats
 </pre><p>
Note that if an empty line is inserted between the comment and the command definition, the command will have an empty description string.<h2><a class="anchor" name="cli_directive">
4. Directive</a></h2>
<h3><a class="anchor" name="cli_directive_ifdef">
4.1 Conditional Inclusion</a></h3>
Directive are used to provide conditional inclusion of commands. For example, suppose we have an embedded system that runs on both the actual hardware platform and on a Linux PC. Some of the hardware diagnostic commands should not be included in the Linux PC simulation.<p>
We can use #ifdef/#endif to conditionally define a set of commands.<p>
<pre>
 #ifdef HW_PLATFORM
 register read &lt;HEX:base_addr&gt; { &lt;HEX:num_words&gt; }
 register write &lt;HEX:base_addr&gt; &lt;HEX:val&gt;
 #endif
 </pre><p>
These two commands of peeking and poking H/W registers will only be available if HW_PLATFORM is provided to <a class="el" href="mk__parser_8py-source.html">mk_parser.py</a>. To define this label, pass "-D HW_PLATFORM" to <a class="el" href="mk__parser_8py-source.html">mk_parser.py</a>.<h3><a class="anchor" name="cli_directive_include">
4.2 CLI Files Inclusion</a></h3>
When the number of commands becomes large, it is inconvenient to hold all commands in a single .cli file. A #include directive is provided to allow file inclusion much like C header inclusion.<p>
For example, we can put the two H/W register command in a file called hw_reg.cli and rewrite the previous block as:<p>
<pre>
 #ifdef HW_PLATFORM
 #include "hw_reg.cli"
 #endif
 </pre><h3><a class="anchor" name="cli_directive_submode">
4.3 Submode</a></h3>
Submode allows the parser to switch to a different parse tree. Submode is a useful feature for creating hierarchy in CLI. Sometimes, a "flat" CLI structure can make it difficult to read configuration. Suppose we have a network router with interfaces. We can configure it using a flat hierarchy.<p>
<pre>
 interface eth0 ip-address 20.1.1.1 255.0.0.0
 interface eth0 acl acl1
 interface eth0 qos qos-profile1
 </pre><p>
or it can use submode to wrap all interface configurations.<p>
<pre>
 interface eth0  &lt;- enter interface submode.
  ip-adress 20.1.1.1 255.0.0.0
  acl acl1
  qos qos-profile1
 </pre><p>
By grouping all interface configuration commands inside interface submode, it reduces the number of top-level commands. This has an implication on the effectiveness of context sensitive help. If a first-time user wants to see what top-level commands are available, he/she can be overwhelmed if all commands belong to the top-level.<p>
To define commands in a submode, wrap those commands between #submode and #endsubmode. For example, the interface submode above looks like this:<p>
<pre>
 interface &lt;STRING:if_name&gt;
 #submode "if"
 ip-address &lt;IPV4ADDR:addr&gt; &lt;IPV4ADDR:mask&gt;
 acl &lt;STRING:acl_name&gt;
 qos &lt;STRING:qos_name&gt;
 #endsubmode
 </pre><p>
A #submode directive requires a submode name. All submode action functions are prefixed by this name after "cparser_cmd_". For example, #submode "if" means all its action functions are prefixed by "cparser_cmd_if_". It must also follow a command. The command that a #submode directive follows is the command that enters the. submode.<p>
Submodes can be nested. The total number of submode plus the top- level is equal to CPARSER_MAX_NESTED_LEVELS.<h2><a class="anchor" name="cli_command">
5. Command Definitions</a></h2>
The following are a list of currently supported tokens. There are two classes of tokens - keywords and parameters. Keywords are strings that form CLI commands. For example, the command "show roster" consists of two keyword tokens ("show" and "roster"). Each keyword should be a string consists of alphabet, digits (0-9), '_' and '-'. Parameters are values entered by users. They have the form of &lt;<em>type</em>:<em>var</em>&gt; where <em>type</em> is the token type and <em>var</em> is a legal C variable name.<p>
CLI parser provides the following parameter token types:<p>
<ul>
<li>STRING - A string without ' '.</li><li>UINT - 32-bit unsigned integer in decimal or hexadecimal. E.g. 0x1234, 312476.</li><li>INT - 32-bit signed integer. E.g., -1234, 13469.</li><li>HEX - 32-bit unsigned integer in form of hexadecimal only. E.g., 0xabc1234.</li><li>FLOAT - 64-bit floating point value. E.g., 0.134, -123.406.</li><li>MACADDR - 48-bit IEEE 802 MAC address. E.g., 00:11:AA:EE:FF.</li><li>IPV4ADDR - IPv4 address. E.g., 10.1.1.1 or 192.168.1.1.</li><li>FILE - A string that represents the path of a file. It is a specialized version of STRING that provides file completion.</li><li>LIST - A string that takes on a set of keywords. Unlike other parameter tokens, it takes on a unique form: &lt;LIST:<em>kw1</em>,<em>kw2</em>,...:<em>var</em>&gt; where 'kw#' are valid keywords and 'var' is the name of the variable. The intention of LIST keyword is reduce the number of similar commands. For example, suppose one have three commands like: 1) show interface ip-address, 2) show interface mtu, 3) show interface counters. One can simplify it to: show interface &lt;LIST:ip-address,mtu,counters:options&gt;. Note that there should not be any spaces between commas.</li></ul>
<h3><a class="anchor" name="cli_extending">
5.1 Extending CLI parser</a></h3>
(<em>In the future, user can extend CLI parser by adding new token types.</em>)<h3><a class="anchor" name="cli_optional">
5.2 Optional parameters</a></h3>
It is possible to include optional parameters in CLI commands. To make a parameter optional, wrap it inside a pair of { }. For example, suppose we define a command that adds 2 or 3 numbers:<p>
add &lt;INT:a&gt; &lt;INT:b&gt; { &lt;INT:c&gt; }<p>
The following are valid inputs:<p>
<pre>
 add 1 2 3
 add 1 2
 </pre><p>
It is possible to have multiple optional parameters in a command but they must be nested. For example, suppose we have a command that adds two to four numbers:<p>
<pre>
 LEGAL: add &lt;INT:a&gt; &lt;INT:b&gt; { &lt;INT:c&gt; { &lt;INT:d&gt; } }
 ILLEGAL: add &lt;INT:a&gt; &lt;INT:b&gt; { &lt;INT:c&gt; } { &lt;INT:d&gt; }
 </pre><p>
There are couple reasons for imposing such restrictions. First, a command with N optional parameters has only N possible acceptable forms with the nesting constraint but 2^N forms without it. Second, there are unresolvable ambiguities without the constraint.<p>
Suppose user inputs "add 1 2 3". Is it c=3 and d is omitted or c is omitted and d=3? With the nesting constraint, c must be 3 and d is omitted.<h3><a class="anchor" name="privileged_mode">
5.3 Privileged Mode</a></h3>
There may be commands that one does not want to be available for everyone. For example, everyone can issue show commands to debug and to monitor the system but only the administrator can issue configuration commands to change the behavior of the system. In this case, it is useful to have a mode that support restricted commands. To mark a command to be a <em>privileged-mode</em> command, simply precede the command with a "+".<h2><a class="anchor" name="cli_example">
6. EXAMPLE</a></h2>
The following is an example of a CLI for a sample employee database program.<p>
<pre>
 // List a summary of employees.
 show employees</pre><p>
<pre> // List detail records of all employees.
 show employees all</pre><p>
<pre> // List all employees within a certain range of employee ids
 show employees-by-id { &lt;UINT:min&gt; { &lt;UINT:max&gt; } }</pre><p>
<pre> // Add a new employee or enter the record of an existing employee
 employee &lt;HEX:id&gt;</pre><p>
<pre> #ifdef TEST_LABEL1
 // This next line tests if file inclusion is handled correctly.
 #include "test_included.cli"
 #endif</pre><p>
<pre> #ifdef TEST_LABEL2
 // This next line tests if not existing label is handled correctly.
 #include "test_not_included.cli"
 #endif</pre><p>
<pre> // Delete an existing employee
 no employee &lt;HEX:id&gt;</pre><p>
<pre> // Save the current roster to a file
 save roster &lt;STRING:filename&gt;</pre><p>
<pre> // Load roster file
 load roster &lt;FILE:filename&gt;</pre><p>
<pre> // List all available commands with a substring 'filter' in it.
 help { &lt;STRING:filter&gt; }</pre><p>
<pre> // Show specific field of an employee.
 show employee &lt;HEX:id&gt; &lt;LIST:height,weight,date-of-birth,title:field&gt;</pre><p>
<pre> // Show the bonus factor of an employee.
 + show employee &lt;HEX:id&gt; bonus-factor</pre><p>
<pre> // Enable privileged mode
 enable privileged-mode</pre><p>
<pre> // Disable privileged mode
 + disable privileged-mode</pre><p>
<pre> // Leave the database
 quit</pre><p>
<pre> </pre> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 7 02:22:44 2011 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
